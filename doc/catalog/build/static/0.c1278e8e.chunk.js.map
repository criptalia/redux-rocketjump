{"version":3,"sources":["webpack:///static/0.c1278e8e.chunk.js","webpack:///./catalog/WELCOME.md?5393","webpack:///./catalog/WELCOME.md"],"names":["webpackJsonp","778","module","exports","__webpack_require__","React","createReactClass","PageRenderer","__esModule","default","WrappedPageRenderer","displayName","getInitialState","content","componentWillMount","render","createElement","Object","assign","this","props","state","__catalog_loader__","779"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,EAASC,GCFjC,GAAAC,GAAAD,EAAA,IACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,KAAAG,YACAA,GAAAC,aACAD,IAAAE,QAEA,IAAAC,GAAAJ,GACAK,YAAA,sBACAC,gBAAA,WACA,OAAgBC,QAAAT,EAAA,OAEhBU,mBAAA,aAUAC,OAAA,WACA,MAAAV,GAAAW,cAAAT,EAAAU,OAAAC,UAAiEC,KAAAC,OAAeP,QAAAM,KAAAE,MAAAR,aAGhFH,GAAAY,oBAAA,EACApB,EAAAC,QAAAO,GDUMa,IACA,SAAUrB,EAAQC,GEtCxBD,EAAAC,QAAA","file":"static/0.c1278e8e.chunk.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 778:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var React = __webpack_require__(15);\n    var createReactClass = __webpack_require__(45);\n    var PageRenderer = __webpack_require__(289).PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: __webpack_require__(779)};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (false) {\n          module.hot.accept(\"!!../node_modules/raw-loader/index.js!./WELCOME.md\", function() {\n            component.setState({\n              content: require(\"!!../node_modules/raw-loader/index.js!./WELCOME.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n/***/ }),\n\n/***/ 779:\n/***/ (function(module, exports) {\n\nmodule.exports = \"```image\\nsrc: catalog_logo.svg\\nplain: true\\n```\\n\\nHi!\\n\\nWelcome to your freshly set up Catalog. To get started immediately, check out the `catalog/` directory (or wherever you've set it up).\\n\\nBELLA!\\nX\\n- `WELCOME.md`: This Markdown document\\n- `index.js`: The entry file to start Catalog. Change configuration and add pages here.\\n- `index.html`: The HTML document which gets served. Usually there's no need to edit this unless for example you want to load a custom font.\\n- `static/`: A directory with files that are served statically. For example the Catalog logo above.\\n\\nFor more details about how to use Catalog, check out the [documentation](https://docs.catalog.style/).\\n\\n# redux-rocketjump\\n[![Build Status](https://travis-ci.org/inmagik/redux-rocketjump.svg?branch=master)](https://travis-ci.org/inmagik/redux-rocketjump)\\n[![npm version](https://badge.fury.io/js/redux-rocketjump.svg)](https://badge.fury.io/js/redux-rocketjump)\\n\\nRocketjump your redux! Speed up redux-app development.\\n\\nA set of tools to speed up the development of an a redux based app:\\n\\n- Generate all you need from and for the state from a single function call, easy to extend, easy to compose.\\n- An out of the box way to organize redux folders by functionality instead of type.\\n- Handy helpers to help you compose functionality.\\n\\n```js\\nimport { rj, makeAppsReducers, makeAppsSaga } from 'redux-rocketjump'\\n\\n// state/index.js\\nimport * as todos from './todos'\\n\\nconst APPS = {\\n  todos,\\n}\\n\\nconst rootReducer = combineReducers({\\n  ...makeAppsReducers(APPS),\\n})\\n\\nconst mainSaga = makeAppsSaga(APPS)\\n\\n// state/todos.js\\nconst moreStuffRj = rj({\\n  proxyActions: {\\n    loadMore: ({ load }) => (params = {}, meta = {}) =>\\n      load(params, { ...meta, more: true }),\\n  },\\n  dataReducer: (prevState, { type, payload, meta }) =>\\n    meta.more ? prevState.concat(payload.data) : payload.data\\n})\\n\\nconst toastOnFailureRj = rj({\\n  failureEffect: function *(error) {\\n    yield put(showErrorToast(`Sorry our monkeys are trying to do their best, ${error.message}`))\\n  }\\n})\\n\\nconst callAuthenticatedRj = rj({\\n  callApi: function *(apiFn, ...args) {\\n    const token = yield select(getAuthToken)\\n    const result = yield call(apiFn, ...args, token)\\n    return result\\n  }\\n})\\n\\nexport const {\\n  actions: { load: loadTodos, unload: unloadTods, loadMore: loadMoreTodos },\\n  selectors: { getData: getTodos, isLoading: isLoadingTodos, getError: getTodosError },\\n  saga,\\n  reducer,\\n} = rj(moreStuffRj, toastOnFailureRj, callAuthenticatedRj)({\\n  type: 'GET_TODOS',\\n  state: 'todos',\\n  api: fetchTodosFromApi,\\n  proxySelectors: {\\n    getData: ({ getData }) => createSelector(getData, todos =>\\n      todos === null ? null : todos.map(todo => ({\\n        ...todo,\\n        asReadMe: `* [${todo.done ? 'v' : ''}] ${todo.title}`\\n      }))\\n    )\\n  },\\n})\\n\\n```\\n\\n## Install\\n\\n```\\nyarn add redux-rocketjump\\n```\\nor\\n```\\nnpm install --save redux-rocketjump\\n```\\n\\n## Install peer dependencies\\n\\nredux-rocketjump uses [redux-saga](https://github.com/redux-saga/redux-saga) to handle side effects,\\nand [reselect](https://github.com/reactjs/reselect) to make ad hoc memoized selectors.\\n```\\nyarn add redux redux-saga reselect\\n```\\nor\\n```\\nnpm install --save redux redux-saga reselect\\n```\\n\\n## Why?\\n\\nWhen develop a large redux app with a lot of entities is some cases this can lead to a lot of copy-paste code an in a difficult to share functionality, redux-rocketjump try to bridge this gap promoting better code organization and\\nautomating certain stuff without loosing control of what you are doing.\\n\\n## Organize redux code by functionality\\nWhen starting writing a redux app is common to organize code by type Es:. (actions, reducers, selectors, ...).\\nBut when the app get bigger this approach lead to confusion, unmantenibility and in a difficult scalability.\\nSo instead yuo should organizing state folders by what they does Es:. (todos, users, tickets, ...).\\n\\nTo do this `redux-rocketjump` offers you two covenient helpers `makeAppsReducers` and `makeAppsSaga`.\\n\\nEvery state folder should export a `reducer` injected into the main reducer and, if needed, a `saga` used to handle side effects.\\n\\nA tipical `state/index.js` looks like this:\\n```js\\nimport { createStore, compose, applyMiddleware, combineReducers } from 'redux'\\nimport createSagaMiddleware from 'redux-saga'\\nimport { makeAppsReducers, makeAppsSaga } from 'redux-rocketjump'\\nimport * as todos from './todos'\\n\\nconst APPS = {\\n  todos,\\n}\\n\\nconst rootReducer = combineReducers({\\n  // HOOK for other reducers...\\n  ...makeAppsReducers(APPS),\\n})\\n\\nconst mainSaga = makeAppsSaga(APPS)\\n\\nconst preloadedState = undefined\\nconst sagaMiddleware = createSagaMiddleware()\\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\\nconst store = createStore(\\n  rootReducer,\\n  preloadedState,\\n  composeEnhancers(\\n    applyMiddleware(sagaMiddleware),\\n  )\\n)\\n\\nsagaMiddleware.run(mainSaga)\\n\\nexport default store\\n```\\n\\n## Your first rocketjump\\nBasically `rocketjump` is just a function that makes action creators, selectors, reducer\\nand saga from a configuration.\\nThe minum options are:\\n- `type`: The action type that trigger side effect and the prefix for related action types dispatched: `type`_LOADING, `type`_SUCCESS, `type`_FAILURE, `type`_UNLOAD.\\n- `state`: The base selector for generated selectors, can be a selector, a function or a string object path with the sintax of https://lodash.com/docs/#get. If `false` was given the reducer and selectors creation is skipped, this is useful when you need only to run action driven side effect in rocketjump environment.\\n- `api`: the side effect, a function that return a promise.\\n\\nSo this is a `rocketjump` for fetching some todos from an API:\\n```js\\n// todos.js\\nimport { rj } from 'redux-rocketjump'\\nexport const {\\n  actions: {\\n    // Trigger side effect\\n    // the first parameter is an object that is passed as argument to the api function\\n    // the second paramter is an object of meta dispached along with all the action dispatched\\n    // you can use meta to customize reducer or saga behaviour from outside.\\n    load: loadTodos,\\n    // Stop side effect and clear the state, accept an object of meta as paramater\\n    unload: unloadTods,\\n  },\\n  selectors: {\\n    // Promise resolved value\\n    getData: getTodos,\\n    // Promise is running?\\n    isLoading: isLoading,\\n    // The promise rejection\\n    getError: getTodsError,\\n  },\\n  // The generated reducer\\n  reducer,\\n  // The generated saga\\n  saga,\\n} = rj({\\n  type: 'GET_TODOS',\\n  state 'todos',\\n  api: params => loadTodosFromApi(params),\\n})()\\n```\\nThis the equivalent without using rocketjump:\\n\\n```js\\n// reducer.js\\nconst defaultState = { loading: false, error: null, data: null  }\\nexport default (prevState = defaultState, { type, payload }) => {\\n  switch (type) {\\n    case 'GET_TODOS_LOADING':\\n      return {\\n        ...prevState,\\n        loading: true,\\n        error: null,\\n      }\\n    case 'GET_TODOS_FAILURE':\\n      return {\\n        ...prevState,\\n        loading: false,\\n        error: payload,\\n      }\\n    case 'GET_TODOS_SUCCESS':\\n      return {\\n        ...prevState,\\n        loading: false,\\n        data: payload.data,\\n      }\\n    case 'GET_TODOS_UNLOAD':\\n      return {\\n        ...prevState,\\n        ...defaultState,\\n      }\\n    default:\\n      return prevState\\n  }\\n}\\n```\\n\\n```js\\n// actions.js\\nexport const loadTodos = (params = {}, meta = {}) => ({\\n  type: 'GET_TODOS'\\n  payload: {\\n    params,\\n  },\\n  meta,\\n})\\n\\nexport const unloadTodos = (meta = {}) => ({\\n  type: 'GET_TODOS_UNLOAD',\\n  meta\\n})\\n```\\n\\n```js\\n// selectors.js\\nexport const getData = state => state.todos.data\\nexport const isLoading = state => state.todos.loading\\nexport const getError = state => state.todos.error\\n```\\n\\n```js\\n// saga.js\\nimport { call, put, takeLatest } from 'redux-saga/effects'\\n\\nfunction* fetchTodos({ payload: { params }, meta }) {\\n  yield put({ type: 'GET_TODOS_LOADING', meta })\\n\\n  try {\\n    const data = yield call(loadTodosFromApi, params)\\n    yield put({ type: 'GET_TODOS_SUCCESS', meta, payload: { data, params } })\\n  } catch (error) {\\n    yield put({ 'GET_TODOS_FAILURE', meta, error: true, payload: error })\\n  }\\n}\\n\\nexport default function* () {\\n  yield takeLatest('GET_TODOS', fetchTodos)\\n}\\n```\\n\\n## Extend the base rocketjump\\nThe base rocketjump can be extendend to change how the reducer work, make new action creators, customize selectors and more.\\nHere the complete list of available options:\\n\\n- `proxyActions`: An hook to proxy action creators, if an object is given every keys is used to generate new action creator, every value is called with all the previous generated action creators and the returned value is expcted to be the new action creator. Previous action creators will be merged with the given new action creators. If function is given, the return value will be used directly to be merge to the previous actions creators.\\n- `proxySelectors`: Works exactly as `proxyActions` but is used to proxy selectors.\\n- `dataReducer`: If given is used as a sub reducer to handle the `type_SUCCESS ` action on the piece of state related to data.\\nThe default implentation is: `(prevState, { type, payload }) => payload.data`\\n- `proxyReducer`: If given, is expected to be a function, it will be called with the previous reducer and the result is used as the new reducer.\\n- `apiExtraParams`: If given, is expected to be a generator, it will be called from a saga with the params coming from the action creator and is used to provide extra paramaters to the `api` function. The return value is expected to be an object it will be merged with the actually `api` paramaters. Here you can use all the `redux-saga` effects, so you can even run asynchronous code. You can even pass an array of generators.\\n- `callApi`: If given is used instead of the `call` function from `redux-saga` to call the `api` function.\\n- `successEffect`: A generator called only when the promise returned from `api` resolves. It receives the resolved value and the meta from the action creator. You can even pass an array of generators.\\n- `failureEffect`: A generator called only when the promise returned from `api` reject. It receives the rejection and the meta from the action creator. You can even pass an array of generators.\\n- `takeEffect`: The effect that describe how the task spawned by the main action type is handled. The default value is `takeLatestAndCancel` that spawn a task every time the main action type is dispatched and cancel any previous tasks, this is usally the best choice for GET api requests.\\nIf you need a different behaviours of you can choose one from [src/effects](https://github.com/inmagik/redux-rocketjump/blob/master/src/effects.js), or you can implement a new one.\\n- `takeEffectArgs`: Extra arguments passed to `takeEffect`.\\n\\nHere some examples to use theese options to handle common tasks.\\n\\nRocketjump that add auth to your api calls:\\n```js\\nimport { rj } from 'redux-rocketjump'\\nimport { select, call } from 'redux-saga/effects'\\n\\nconst rjAuth = rj({\\n  callApi: function *(apiFn, ...args) {\\n    const token = yield select(state => state.auth.accessToken)\\n    const result = yield call(apiFn, ...args, token)\\n    return result\\n  }\\n})\\n\\n```\\n\\nRocketjump that load more stuff from a paginated api:\\n```js\\nimport { rj, getOrSelect } from 'redux-rocketjump'\\nimport { select } from 'redux-saga/effects'\\n\\nconst rjLoadMore = (config, ...args) = rj({\\n  apiExtraParams: function (params, meta) {\\n    if (meta.loadMore) {\\n      const next = yield select(getOrSelect(state, config.state).pagination.next)\\n      return { next }\\n    }\\n  }\\n})(config, ...args)\\n```\\n\\nRocketjump that show a message on success:\\n```js\\nimport { rj } from 'redux-rocketjump'\\nimport { put } from 'redux-saga/effects'\\n\\nconst rjOkMsg = rj({\\n  successEffect: function (data, meta) {\\n    if (meta.successMessage) {\\n      yield put(showSuccessMessage(meta.successMessage))\\n    }\\n  }\\n})\\n```\\n\\n## Compose rocketjumps\\n\\nRocketjump is thought with the composition in mind, a rocketjump can be called with one or a list of partial evaluated rocketjumps or configurations. Only when a rocketjump is called the second time reducer, actions, saga and selectors are created. All the given partial evaluated rocketjumps or configurations are composed together.\\n\\nTake the following pseudo-code:\\n\\n```js\\nconst rj1 = rj({ /* config */ })\\n\\nconst rj2 = rj({ /* config */ })\\n\\nconst { /* actions, reducers, ... */ } = rj(\\n  rj1,\\n  rj2,\\n  {/* config */ },\\n)({ /* config */  })\\n```\\n\\nWhen you call the last rocketjump the second time actions, reducer, actions and selectors are created using rj1 after they are passed to rj2 which generates new ones and so on.\\n\\nRegarding the saga it can't be composed as the others, instead all the extra parameters generated by the `apiExtraParams` are merged together recursively and the effects of `successEffect` or the `failureEffect` are runned consecutively.\\n\\n## Handy helpers\\nredux-rocketjump exports two handy helpers `composeReducers` and `resetReducerOn` to help you composin rocketjumps reducers behaviours, here an example:\\n```js\\nimport { rj, resetReducerOn, composeReducers, makeActionTypes } from 'redux-rocketjump'\\n\\nconst rjCountFails = (config = {}, ...args) => rj({\\n  proxyReducer: r => {\\n    const actionTypes = makeActionTypes(config.type)\\n    return composeReducers(r, (prevState = { failureCount: 0 }, { type, payload }) => {\\n      switch (type) {\\n        case actionTypes.failure:\\n          return {\\n            ...prevState,\\n            failureCount: prevState.failureCount + 1,\\n          }\\n        case actionTypes.unload:\\n          return {\\n            ...prevState,\\n            failureCount: 0,\\n          }\\n        default:\\n          return prevState\\n      }\\n    })\\n  }\\n})(config = {}, ...args)\\n\\nconst rjResetOnLogout = rj({\\n  proxyReducer: r => resetReducerOn('LOGOUT', r),\\n})\\n```\\n\\n## Catalogs\\nOut of the box there are some useful \\\"catalogs\\\" that you can use in composition with rocketjump to extend the base functionality.\\n\\n### Promise\\nThis catalog add promise to action creator using the awesome library [redux-saga-thunk](https://github.com/diegohaz/redux-saga-thunk).\\n```js\\nimport rjWithPromise from 'redux-rocketjump/catalogs/promise'\\nconst {\\n  actions: {\\n    load,\\n  },\\n  saga,\\n } = rj(rjWithPromise)({\\n  type: 'GET_TODOS',\\n  state: 'todos',\\n  api: loadTodosFromApi,\\n})\\n\\n// ... next ...\\nstore.dispatch(load())\\n  .then(() => /* ... */)\\n  .catch(() => /* ... */)\\n\\n```\\n\\n\\n## Example\\nYou can find an example under [example](https://github.com/inmagik/redux-rocketjump/tree/master/example), it's a simple REST todo app that uses the great [json-server](https://github.com/typicode/json-server) as fake API server.\\n\\nTo run it first clone the repo:\\n```\\ngit clone git@github.com:inmagik/redux-rocketjump.git\\n```\\n\\nThen run:\\n```\\nyarn install\\nyarn start\\n```\\nOr using npm:\\n```\\nnpm install\\nnpm start\\n```\\n\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/0.c1278e8e.chunk.js","\n    var React = require('react');\n    var createReactClass = require('create-react-class');\n    var PageRenderer = require('catalog').PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: require(\"!!../node_modules/raw-loader/index.js!./WELCOME.md\")};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (module.hot) {\n          module.hot.accept(\"!!../node_modules/raw-loader/index.js!./WELCOME.md\", function() {\n            component.setState({\n              content: require(\"!!../node_modules/raw-loader/index.js!./WELCOME.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./catalog/WELCOME.md\n// module id = 778\n// module chunks = 0","module.exports = \"```image\\nsrc: catalog_logo.svg\\nplain: true\\n```\\n\\nHi!\\n\\nWelcome to your freshly set up Catalog. To get started immediately, check out the `catalog/` directory (or wherever you've set it up).\\n\\nBELLA!\\nX\\n- `WELCOME.md`: This Markdown document\\n- `index.js`: The entry file to start Catalog. Change configuration and add pages here.\\n- `index.html`: The HTML document which gets served. Usually there's no need to edit this unless for example you want to load a custom font.\\n- `static/`: A directory with files that are served statically. For example the Catalog logo above.\\n\\nFor more details about how to use Catalog, check out the [documentation](https://docs.catalog.style/).\\n\\n# redux-rocketjump\\n[![Build Status](https://travis-ci.org/inmagik/redux-rocketjump.svg?branch=master)](https://travis-ci.org/inmagik/redux-rocketjump)\\n[![npm version](https://badge.fury.io/js/redux-rocketjump.svg)](https://badge.fury.io/js/redux-rocketjump)\\n\\nRocketjump your redux! Speed up redux-app development.\\n\\nA set of tools to speed up the development of an a redux based app:\\n\\n- Generate all you need from and for the state from a single function call, easy to extend, easy to compose.\\n- An out of the box way to organize redux folders by functionality instead of type.\\n- Handy helpers to help you compose functionality.\\n\\n```js\\nimport { rj, makeAppsReducers, makeAppsSaga } from 'redux-rocketjump'\\n\\n// state/index.js\\nimport * as todos from './todos'\\n\\nconst APPS = {\\n  todos,\\n}\\n\\nconst rootReducer = combineReducers({\\n  ...makeAppsReducers(APPS),\\n})\\n\\nconst mainSaga = makeAppsSaga(APPS)\\n\\n// state/todos.js\\nconst moreStuffRj = rj({\\n  proxyActions: {\\n    loadMore: ({ load }) => (params = {}, meta = {}) =>\\n      load(params, { ...meta, more: true }),\\n  },\\n  dataReducer: (prevState, { type, payload, meta }) =>\\n    meta.more ? prevState.concat(payload.data) : payload.data\\n})\\n\\nconst toastOnFailureRj = rj({\\n  failureEffect: function *(error) {\\n    yield put(showErrorToast(`Sorry our monkeys are trying to do their best, ${error.message}`))\\n  }\\n})\\n\\nconst callAuthenticatedRj = rj({\\n  callApi: function *(apiFn, ...args) {\\n    const token = yield select(getAuthToken)\\n    const result = yield call(apiFn, ...args, token)\\n    return result\\n  }\\n})\\n\\nexport const {\\n  actions: { load: loadTodos, unload: unloadTods, loadMore: loadMoreTodos },\\n  selectors: { getData: getTodos, isLoading: isLoadingTodos, getError: getTodosError },\\n  saga,\\n  reducer,\\n} = rj(moreStuffRj, toastOnFailureRj, callAuthenticatedRj)({\\n  type: 'GET_TODOS',\\n  state: 'todos',\\n  api: fetchTodosFromApi,\\n  proxySelectors: {\\n    getData: ({ getData }) => createSelector(getData, todos =>\\n      todos === null ? null : todos.map(todo => ({\\n        ...todo,\\n        asReadMe: `* [${todo.done ? 'v' : ''}] ${todo.title}`\\n      }))\\n    )\\n  },\\n})\\n\\n```\\n\\n## Install\\n\\n```\\nyarn add redux-rocketjump\\n```\\nor\\n```\\nnpm install --save redux-rocketjump\\n```\\n\\n## Install peer dependencies\\n\\nredux-rocketjump uses [redux-saga](https://github.com/redux-saga/redux-saga) to handle side effects,\\nand [reselect](https://github.com/reactjs/reselect) to make ad hoc memoized selectors.\\n```\\nyarn add redux redux-saga reselect\\n```\\nor\\n```\\nnpm install --save redux redux-saga reselect\\n```\\n\\n## Why?\\n\\nWhen develop a large redux app with a lot of entities is some cases this can lead to a lot of copy-paste code an in a difficult to share functionality, redux-rocketjump try to bridge this gap promoting better code organization and\\nautomating certain stuff without loosing control of what you are doing.\\n\\n## Organize redux code by functionality\\nWhen starting writing a redux app is common to organize code by type Es:. (actions, reducers, selectors, ...).\\nBut when the app get bigger this approach lead to confusion, unmantenibility and in a difficult scalability.\\nSo instead yuo should organizing state folders by what they does Es:. (todos, users, tickets, ...).\\n\\nTo do this `redux-rocketjump` offers you two covenient helpers `makeAppsReducers` and `makeAppsSaga`.\\n\\nEvery state folder should export a `reducer` injected into the main reducer and, if needed, a `saga` used to handle side effects.\\n\\nA tipical `state/index.js` looks like this:\\n```js\\nimport { createStore, compose, applyMiddleware, combineReducers } from 'redux'\\nimport createSagaMiddleware from 'redux-saga'\\nimport { makeAppsReducers, makeAppsSaga } from 'redux-rocketjump'\\nimport * as todos from './todos'\\n\\nconst APPS = {\\n  todos,\\n}\\n\\nconst rootReducer = combineReducers({\\n  // HOOK for other reducers...\\n  ...makeAppsReducers(APPS),\\n})\\n\\nconst mainSaga = makeAppsSaga(APPS)\\n\\nconst preloadedState = undefined\\nconst sagaMiddleware = createSagaMiddleware()\\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\\nconst store = createStore(\\n  rootReducer,\\n  preloadedState,\\n  composeEnhancers(\\n    applyMiddleware(sagaMiddleware),\\n  )\\n)\\n\\nsagaMiddleware.run(mainSaga)\\n\\nexport default store\\n```\\n\\n## Your first rocketjump\\nBasically `rocketjump` is just a function that makes action creators, selectors, reducer\\nand saga from a configuration.\\nThe minum options are:\\n- `type`: The action type that trigger side effect and the prefix for related action types dispatched: `type`_LOADING, `type`_SUCCESS, `type`_FAILURE, `type`_UNLOAD.\\n- `state`: The base selector for generated selectors, can be a selector, a function or a string object path with the sintax of https://lodash.com/docs/#get. If `false` was given the reducer and selectors creation is skipped, this is useful when you need only to run action driven side effect in rocketjump environment.\\n- `api`: the side effect, a function that return a promise.\\n\\nSo this is a `rocketjump` for fetching some todos from an API:\\n```js\\n// todos.js\\nimport { rj } from 'redux-rocketjump'\\nexport const {\\n  actions: {\\n    // Trigger side effect\\n    // the first parameter is an object that is passed as argument to the api function\\n    // the second paramter is an object of meta dispached along with all the action dispatched\\n    // you can use meta to customize reducer or saga behaviour from outside.\\n    load: loadTodos,\\n    // Stop side effect and clear the state, accept an object of meta as paramater\\n    unload: unloadTods,\\n  },\\n  selectors: {\\n    // Promise resolved value\\n    getData: getTodos,\\n    // Promise is running?\\n    isLoading: isLoading,\\n    // The promise rejection\\n    getError: getTodsError,\\n  },\\n  // The generated reducer\\n  reducer,\\n  // The generated saga\\n  saga,\\n} = rj({\\n  type: 'GET_TODOS',\\n  state 'todos',\\n  api: params => loadTodosFromApi(params),\\n})()\\n```\\nThis the equivalent without using rocketjump:\\n\\n```js\\n// reducer.js\\nconst defaultState = { loading: false, error: null, data: null  }\\nexport default (prevState = defaultState, { type, payload }) => {\\n  switch (type) {\\n    case 'GET_TODOS_LOADING':\\n      return {\\n        ...prevState,\\n        loading: true,\\n        error: null,\\n      }\\n    case 'GET_TODOS_FAILURE':\\n      return {\\n        ...prevState,\\n        loading: false,\\n        error: payload,\\n      }\\n    case 'GET_TODOS_SUCCESS':\\n      return {\\n        ...prevState,\\n        loading: false,\\n        data: payload.data,\\n      }\\n    case 'GET_TODOS_UNLOAD':\\n      return {\\n        ...prevState,\\n        ...defaultState,\\n      }\\n    default:\\n      return prevState\\n  }\\n}\\n```\\n\\n```js\\n// actions.js\\nexport const loadTodos = (params = {}, meta = {}) => ({\\n  type: 'GET_TODOS'\\n  payload: {\\n    params,\\n  },\\n  meta,\\n})\\n\\nexport const unloadTodos = (meta = {}) => ({\\n  type: 'GET_TODOS_UNLOAD',\\n  meta\\n})\\n```\\n\\n```js\\n// selectors.js\\nexport const getData = state => state.todos.data\\nexport const isLoading = state => state.todos.loading\\nexport const getError = state => state.todos.error\\n```\\n\\n```js\\n// saga.js\\nimport { call, put, takeLatest } from 'redux-saga/effects'\\n\\nfunction* fetchTodos({ payload: { params }, meta }) {\\n  yield put({ type: 'GET_TODOS_LOADING', meta })\\n\\n  try {\\n    const data = yield call(loadTodosFromApi, params)\\n    yield put({ type: 'GET_TODOS_SUCCESS', meta, payload: { data, params } })\\n  } catch (error) {\\n    yield put({ 'GET_TODOS_FAILURE', meta, error: true, payload: error })\\n  }\\n}\\n\\nexport default function* () {\\n  yield takeLatest('GET_TODOS', fetchTodos)\\n}\\n```\\n\\n## Extend the base rocketjump\\nThe base rocketjump can be extendend to change how the reducer work, make new action creators, customize selectors and more.\\nHere the complete list of available options:\\n\\n- `proxyActions`: An hook to proxy action creators, if an object is given every keys is used to generate new action creator, every value is called with all the previous generated action creators and the returned value is expcted to be the new action creator. Previous action creators will be merged with the given new action creators. If function is given, the return value will be used directly to be merge to the previous actions creators.\\n- `proxySelectors`: Works exactly as `proxyActions` but is used to proxy selectors.\\n- `dataReducer`: If given is used as a sub reducer to handle the `type_SUCCESS ` action on the piece of state related to data.\\nThe default implentation is: `(prevState, { type, payload }) => payload.data`\\n- `proxyReducer`: If given, is expected to be a function, it will be called with the previous reducer and the result is used as the new reducer.\\n- `apiExtraParams`: If given, is expected to be a generator, it will be called from a saga with the params coming from the action creator and is used to provide extra paramaters to the `api` function. The return value is expected to be an object it will be merged with the actually `api` paramaters. Here you can use all the `redux-saga` effects, so you can even run asynchronous code. You can even pass an array of generators.\\n- `callApi`: If given is used instead of the `call` function from `redux-saga` to call the `api` function.\\n- `successEffect`: A generator called only when the promise returned from `api` resolves. It receives the resolved value and the meta from the action creator. You can even pass an array of generators.\\n- `failureEffect`: A generator called only when the promise returned from `api` reject. It receives the rejection and the meta from the action creator. You can even pass an array of generators.\\n- `takeEffect`: The effect that describe how the task spawned by the main action type is handled. The default value is `takeLatestAndCancel` that spawn a task every time the main action type is dispatched and cancel any previous tasks, this is usally the best choice for GET api requests.\\nIf you need a different behaviours of you can choose one from [src/effects](https://github.com/inmagik/redux-rocketjump/blob/master/src/effects.js), or you can implement a new one.\\n- `takeEffectArgs`: Extra arguments passed to `takeEffect`.\\n\\nHere some examples to use theese options to handle common tasks.\\n\\nRocketjump that add auth to your api calls:\\n```js\\nimport { rj } from 'redux-rocketjump'\\nimport { select, call } from 'redux-saga/effects'\\n\\nconst rjAuth = rj({\\n  callApi: function *(apiFn, ...args) {\\n    const token = yield select(state => state.auth.accessToken)\\n    const result = yield call(apiFn, ...args, token)\\n    return result\\n  }\\n})\\n\\n```\\n\\nRocketjump that load more stuff from a paginated api:\\n```js\\nimport { rj, getOrSelect } from 'redux-rocketjump'\\nimport { select } from 'redux-saga/effects'\\n\\nconst rjLoadMore = (config, ...args) = rj({\\n  apiExtraParams: function (params, meta) {\\n    if (meta.loadMore) {\\n      const next = yield select(getOrSelect(state, config.state).pagination.next)\\n      return { next }\\n    }\\n  }\\n})(config, ...args)\\n```\\n\\nRocketjump that show a message on success:\\n```js\\nimport { rj } from 'redux-rocketjump'\\nimport { put } from 'redux-saga/effects'\\n\\nconst rjOkMsg = rj({\\n  successEffect: function (data, meta) {\\n    if (meta.successMessage) {\\n      yield put(showSuccessMessage(meta.successMessage))\\n    }\\n  }\\n})\\n```\\n\\n## Compose rocketjumps\\n\\nRocketjump is thought with the composition in mind, a rocketjump can be called with one or a list of partial evaluated rocketjumps or configurations. Only when a rocketjump is called the second time reducer, actions, saga and selectors are created. All the given partial evaluated rocketjumps or configurations are composed together.\\n\\nTake the following pseudo-code:\\n\\n```js\\nconst rj1 = rj({ /* config */ })\\n\\nconst rj2 = rj({ /* config */ })\\n\\nconst { /* actions, reducers, ... */ } = rj(\\n  rj1,\\n  rj2,\\n  {/* config */ },\\n)({ /* config */  })\\n```\\n\\nWhen you call the last rocketjump the second time actions, reducer, actions and selectors are created using rj1 after they are passed to rj2 which generates new ones and so on.\\n\\nRegarding the saga it can't be composed as the others, instead all the extra parameters generated by the `apiExtraParams` are merged together recursively and the effects of `successEffect` or the `failureEffect` are runned consecutively.\\n\\n## Handy helpers\\nredux-rocketjump exports two handy helpers `composeReducers` and `resetReducerOn` to help you composin rocketjumps reducers behaviours, here an example:\\n```js\\nimport { rj, resetReducerOn, composeReducers, makeActionTypes } from 'redux-rocketjump'\\n\\nconst rjCountFails = (config = {}, ...args) => rj({\\n  proxyReducer: r => {\\n    const actionTypes = makeActionTypes(config.type)\\n    return composeReducers(r, (prevState = { failureCount: 0 }, { type, payload }) => {\\n      switch (type) {\\n        case actionTypes.failure:\\n          return {\\n            ...prevState,\\n            failureCount: prevState.failureCount + 1,\\n          }\\n        case actionTypes.unload:\\n          return {\\n            ...prevState,\\n            failureCount: 0,\\n          }\\n        default:\\n          return prevState\\n      }\\n    })\\n  }\\n})(config = {}, ...args)\\n\\nconst rjResetOnLogout = rj({\\n  proxyReducer: r => resetReducerOn('LOGOUT', r),\\n})\\n```\\n\\n## Catalogs\\nOut of the box there are some useful \\\"catalogs\\\" that you can use in composition with rocketjump to extend the base functionality.\\n\\n### Promise\\nThis catalog add promise to action creator using the awesome library [redux-saga-thunk](https://github.com/diegohaz/redux-saga-thunk).\\n```js\\nimport rjWithPromise from 'redux-rocketjump/catalogs/promise'\\nconst {\\n  actions: {\\n    load,\\n  },\\n  saga,\\n } = rj(rjWithPromise)({\\n  type: 'GET_TODOS',\\n  state: 'todos',\\n  api: loadTodosFromApi,\\n})\\n\\n// ... next ...\\nstore.dispatch(load())\\n  .then(() => /* ... */)\\n  .catch(() => /* ... */)\\n\\n```\\n\\n\\n## Example\\nYou can find an example under [example](https://github.com/inmagik/redux-rocketjump/tree/master/example), it's a simple REST todo app that uses the great [json-server](https://github.com/typicode/json-server) as fake API server.\\n\\nTo run it first clone the repo:\\n```\\ngit clone git@github.com:inmagik/redux-rocketjump.git\\n```\\n\\nThen run:\\n```\\nyarn install\\nyarn start\\n```\\nOr using npm:\\n```\\nnpm install\\nnpm start\\n```\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/raw-loader!./catalog/WELCOME.md\n// module id = 779\n// module chunks = 0"],"sourceRoot":""}